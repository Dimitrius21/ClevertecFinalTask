API приложения RESTful web-service, реализующий функционал для работы с системой управления новостями:
К сущности Comment:
 - может осуществлять любой пользователь:
GET : /api/comment/{id}–  получить Comment по id. Возвращается Json CommentDto со следующими данными {"id", "time", "text", "username", "newsId"}
GET : /api/comment/has?field=поле&value=значение&[page=номер&size=количество&sort=name-asc/desc]  – найти(получить) список Comment по содержимому
полей text/username. Можно указать field=поле&value=значение несколько раз для разных полей. Опционально можно задать разбиение
вывода постранично, а также отсортировать информацию по указанному полю. Значения asc – по возрастанию, desc – по убыванию. По умолчанию извлекаются
первые 20 записей (без сортировки).
 - Следующие запросы могут осуществлять только зарегистрированные и аутентифицированные пользователи-подписчики (описано далее):
POST: /api/comment – сохраняет Comment и возвращает объект с присвоенным id. В теле запроса содержится JSON объекта CommentDto для сохранения
(пример {"id" : 0, "time" : 0, "text" : "Текст комментария", "username" : "имя пользователя", "newsId" : 1} - поля id и time могут отсутствовать
во входном объекте. Имя пользователя должно браться из зарегистрированных пользователей в сервисе аутентификации)
PUT: /api/comment – внести изменения в текст комментария. В теле запроса содержится JSON объекта CommentDto для обновления
(пример {"id" : 1, "time" : 0, "text" : "Новый текст комментария", "username" : "имя пользователя", "newsId" : 1}. Возвращается JSON
измененного объекта CommentDto.
DELETE: /api/comment/{id} – удаляет Comment с указанным id.  

К сущности News
 - может осуществлять любой пользователь:
GET : /api/news/{id}–  получить News по id. Возвращается Json NewsShortDto со следующими данными {"id", "time", "title", "text", "username"}
GET : /api/news/{id}/comments[?page=номер&size=количество&sort=name-asc/desc] – получить News по id со списком Comment к ней. Опционально можно
задать разбиение вывода постранично, а также отсортировать информацию по указанному. Значения asc – по возрастанию, desc – по убыванию.
По умолчанию извлекаются первые 20 записей (без сортировки). Возвращается Json NewsFullDto со следующими данными {"id", "time", "title",
"text", "username", "List of comments"}
GET : /api/news[?page=номер&size=количество&sort=name-asc/desc] - Получить список всех News.  Опционально можно задать разбиение вывода
постранично, а также отсортировать информацию по указанному. Значения asc – по возрастанию, desc – по убыванию. По умолчанию извлекаются
первые 20 записей (без сортировки).  Возвращается Json NewsShortDto со следующими данными {"id", "time", "title", "text", "username"}
GET : /api/news/has?field=поле&value=значение&[page=номер&size=количество&sort=name-asc/desc]  – найти(получить) список News по содержимому
полей time/title/text/username. Можно указать field=поле&value=значение несколько раз для разных нескольких полей. Опционально можно задать
разбиение вывода постранично, а также отсортировать информацию по указанному полю. Значения asc – по возрастанию, desc – по убыванию.
По умолчанию извлекаются первые 20 записей (без сортировки).
 - Следующие запросы могут осуществлять только зарегистрированные и аутентифицированные пользователи-журналисты (описано далее)
POST: /api/news – сохраняет News и возвращает объект с присвоенным id. В теле запроса содержится JSON объекта NewsShortDto для сохранения
(пример {"id" : 0, "time" : 0, "title" : "Заголовок новости", "text" : "Текст новости", "username" : "имя пользователя"} - поля id и time могут отсутствовать
во входном объекте. Имя пользователя должно браться из зарегистрированных пользователей в сервисе аутентификации)
PUT: /api/news – внести изменения в title и/или text News. В теле запроса содержится JSON объекта NewsShortDto для обновления
(пример {"id" : 1, "time" : 0, "title" : "Новый заголовок", "text" : "Новый текст", "username" : "имя пользователя"}. Возвращается JSON
измененного объекта NewsShortDto.
DELETE: /api/news/{id} – удаляет News с указанным id.

Аутентификация и авторизация пользователя проводятся следующим образом:
Заголовок Authorization должен содержать или JwtToken (Bearer token) или же имя и пароль (Basic Base64(username:password) - в этом случае приложение
самоcтоятельно сделает запрос в сервис авторизации и получит данные ввиде того-же JwtToken. Далее на основании этих данных проверяется возможность
выполнения запроса.

Сервис авторизации (работает на порту 8090). Запросы:
POST : /auth/jwt - получить JwtToken для пользователя. Данные пользователя передаются в теле запроса ввиде Json объекта UserMainDto (пример
{ "username" : "admin", "password" : "100").
POST : /auth/user - зарегистрировать пользователя - Подписчик (role subscriber). В теле запроса Json объекта UserDto содержащий
{ "username", "password", "email"};
POST : /auth/journalist - зарегистрировать пользователя - -	Журналист (role journalist). В теле запроса Json объекта UserDto содержащий
{ "username", "password", "email"}. Внести пользователя с данной ролью может только Admin - система запросит его данные.
В качестве тестовых данных в систему при запуске вводятся следующие пользователи:
 - username - 'admin', пароль '100' - role admin
 - username - 'Mark', пароль '200' - role journalist
 - username - 'Sema', пароль '300' - role subscriber
 - username - 'David', пароль '400' - role journalist

Для кэширования сущностей в настройках необходимо задать:
caching:
  repository: newsRepository, commentRepository - имена классов репозиториев кэшируемых сущностей
caching:
  type : lru/lfu - тип реализации способа кэширования
  size : 5   - размер кэша
Альтернативно, в случае задания активным профиля 'redis' возможно задать использовать в качестве кэша Redis, при этом
caching.type не задается.

Настройки основного сервиса запрашиваются в отдельном сервисе (реализован на основе Spring Cloud Config)

Для запуска приложения - docker-compose up.







